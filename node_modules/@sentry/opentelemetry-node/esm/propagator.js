import { trace, isSpanContextValid, propagation, TraceFlags } from '@opentelemetry/api';
import { W3CBaggagePropagator, isTracingSuppressed } from '@opentelemetry/core';
import { SENTRY_BAGGAGE_KEY_PREFIX, extractTraceparentData, baggageHeaderToDynamicSamplingContext } from '@sentry/utils';
import { SENTRY_TRACE_HEADER, SENTRY_TRACE_PARENT_CONTEXT_KEY, SENTRY_BAGGAGE_HEADER, SENTRY_DYNAMIC_SAMPLING_CONTEXT_KEY } from './constants.js';
import { SENTRY_SPAN_PROCESSOR_MAP } from './spanprocessor.js';

/**
 * Injects and extracts `sentry-trace` and `baggage` headers from carriers.
 */
class SentryPropagator extends W3CBaggagePropagator {
  /**
   * @inheritDoc
   */
   inject(context, carrier, setter) {
    const spanContext = trace.getSpanContext(context);
    if (!spanContext || !isSpanContextValid(spanContext) || isTracingSuppressed(context)) {
      return;
    }

    let baggage = propagation.getBaggage(context) || propagation.createBaggage({});

    const span = SENTRY_SPAN_PROCESSOR_MAP.get(spanContext.spanId);
    if (span) {
      setter.set(carrier, SENTRY_TRACE_HEADER, span.toTraceparent());

      if (span.transaction) {
        const dynamicSamplingContext = span.transaction.getDynamicSamplingContext();
        baggage = Object.entries(dynamicSamplingContext).reduce((b, [dscKey, dscValue]) => {
          if (dscValue) {
            return b.setEntry(`${SENTRY_BAGGAGE_KEY_PREFIX}${dscKey}`, { value: dscValue });
          }
          return b;
        }, baggage);
      }
    }
    super.inject(propagation.setBaggage(context, baggage), carrier, setter);
  }

  /**
   * @inheritDoc
   */
   extract(context, carrier, getter) {
    let newContext = context;

    const maybeSentryTraceHeader = getter.get(carrier, SENTRY_TRACE_HEADER);
    if (maybeSentryTraceHeader) {
      const header = Array.isArray(maybeSentryTraceHeader) ? maybeSentryTraceHeader[0] : maybeSentryTraceHeader;
      const traceparentData = extractTraceparentData(header || '');
      newContext = newContext.setValue(SENTRY_TRACE_PARENT_CONTEXT_KEY, traceparentData);
      if (traceparentData) {
        const spanContext = {
          traceId: traceparentData.traceId || '',
          spanId: traceparentData.parentSpanId || '',
          isRemote: true,
          // Always sample if traceparent exists, we use SentrySpanProcessor to make sampling decisions with `startTransaction`.
          traceFlags: TraceFlags.SAMPLED,
        };
        newContext = trace.setSpanContext(newContext, spanContext);
      }
    }

    const maybeBaggageHeader = getter.get(carrier, SENTRY_BAGGAGE_HEADER);
    const dynamicSamplingContext = baggageHeaderToDynamicSamplingContext(maybeBaggageHeader);
    newContext = newContext.setValue(SENTRY_DYNAMIC_SAMPLING_CONTEXT_KEY, dynamicSamplingContext);

    return newContext;
  }

  /**
   * @inheritDoc
   */
   fields() {
    return [SENTRY_TRACE_HEADER, SENTRY_BAGGAGE_HEADER];
  }
}

export { SentryPropagator };
//# sourceMappingURL=propagator.js.map
